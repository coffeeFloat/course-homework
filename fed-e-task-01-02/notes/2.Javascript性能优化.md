## 一.内存管理
#### 1.基本流程
```
// 申请
let obj = {};

// 使用
obj.name = 'lg';

// 释放
obj = null;

```
#### 2.javascript中的垃圾
- javascript中内存管理是自动的
- 对象不再被引用时是垃圾
- 对象不能从根上访问时是垃圾

#### 3.javascript中的可达对象
- 可以访问到的对象（引用、作用域链）
- 可达的标准：从根上出发能够被找到
- JavaScript中的根可以理解为全局变量对象

当对象不可达时 就会被v8引擎进行回收

## 二.垃圾回收与常见GC算法
#### 1.GC算法的定义与作用
- GC：垃圾回收机制的简写 （Garbage Collection）
- 作用：找到内存中的垃圾、释放以及回收空间
- 垃圾：程序中不再需要使用的对象等
- 算法：工作时查找和回收所遵循的规则

#### 2.常见GC算法
- 引用计数
- 标记清除
- 标记整理
- 分代回收

#### 1.引用计数算法
###### 实现原理：
- 核心思想：设置引用数，判断当前引用数是否为0
- 引用计数器
- 引用关系改变时修改引用数字
- 引用数字为0时立即回收

###### 引用计数算法优点：
- 发现垃圾时立即回收
- 最大限度减少程序暂停 减少程序卡顿时间: 当引用计数发现内存将满时，就会查找计数为0的数据 并进行内存回收

###### 缺点：
- 无法对循环引用的对象进行回收
- 时间开销大: 需要对所有数据进行计数监听，当数据量大时，计数会消耗大量时间。
```
// 循环引用
function fn() {
  const obj1 = {name: 'Tom'};
  const obj2 = {name: 'Jack'};
  return '';
}
fn();

```

#### 2.标记清除算法（v8引擎会用到）：
###### 实现原理：
- 核心思想：分标记和清除两个阶段
- 遍历所有对象找标记活动对象
- 遍历所有对象清除没有标记对象
- 回收相应的空间
- 清除所有标记， 重新开始遍历。周而复始
- 将释放的空间放入空闲列表 供以后使用

#### 3.标记整理算法
- 可以看做是标记清除的增强
- 标记操作与标记清除算法一致
- 清除阶段会先执行整理，移动对象位置，使释放的空间连续化、最大化

###### 优缺点
1. 优点：相比于引用清除算法 可以清除相互引用的对象
2. 缺点：内存释放会造成空间的碎片化，不利于内存的最大化使用

## 三.V8引擎的垃圾回收
#### 1.认识V8
- V8是一款主流的JavaScript执行引擎 chrome浏览器、Node.js运行平台都是以V8为执行引擎
- V8采用即时编译 所以速度比较快
- V8内存设限 64位为 <=1.5GB 32位为<= 800MB

#### 2.V8垃圾回收策略
- 采用分代回收的思想
- 内存分为新生代、老年代
- 针对不同对象采用不同算法

#### 3.V8中常用的GC算法
- 分代回收
- 空间复制
- 标记清除
- 标记整理
- 标记增量

#### 4.V8内存分配
- 内存空间一分为二
- 小空间用于存储新生代对象（64位：32M 32位： 16M）大空间存储老年代对象
- 新生代指的是存活时间较短的对象 例如：局部作用域的对象

#### 5.新生代对象回收实现
- 回收过程采用复制算法 + 标记整理算法
- 新生代内存分为2个等大空间
- 新生代区域垃圾回收使用空间换时间

##### 回收过程
1. 内存分为 使用空间From, 空闲空间To
2. 声明对象全部在From空间。
3. 当空间达到一定大小后，会采用标记整理算法对From空间的活动对象进行标记
4. 采用复制算法，将活动对象拷贝至To空间
5. From与To空间进行交换，原From空间进行释放，原To空间转为From空间

##### 晋升现象
- 晋升：将新生代对象移动至老年代（满足以下任何一个条件就可以：）
- 经过1轮GC还存活的新生代需要晋升
- To空间的使用率超过25%

#### 6.老年代对象回收

###### 老年代对象说明
- 内存空间 64位系统 <= 1.4GB  32位系统 <= 700M
- 指的是存活时间较长的对象 如：全局对象、闭包中的对象

###### 老年代对象回收实现：
- 主要采用标记清除、标记整理、增量标记算法
- 首先使用标记清除完成垃圾回收（内存大，采用标记清除效率高）
- 当新生代对象需要转移至老年代存储空间时且老年代存储空间不足时 会采用标记整理进行空间优化
- 采用增量标记进行效率优化

###### 增量标记优化老年代垃圾回收
- 将程序执行与对象标记交替进行 尽可能减少对象标记造成的卡顿 提高用户体验
- 交替进行 逐步标记的方式称增量标记

## 四.Performance工具
#### 1.为何需要使用该工具？
可以实时监控内存的情况

#### 2.基本使用步骤：
1. 打开浏览器（最好为Chrome）输入目标网址
2. 打开开发人员工具、切换到性能选项
3. 开启录制功能，访问目标地址
4. 执行用户行为，一段时间后停止录制
5. 分析界面中记录的内存信息

#### 3.内存问题的外在体现：
- 页面出现延迟加载或经常性暂停. 可能由于频繁的GC操作造成
- 页面持续性出现糟糕的性能。可能是由于页面占据较大的内存空间，导致内存空间不足 即内存膨胀
- 页面的性能随时间延长越来越差。 可能是由于内存占据越来越多 即内存泄露

#### 4.监控内存的几种方式：
- 浏览器任务管理器
- Timeline时序图记录
- 堆快照查找分离DOM（内存泄露）
- 判断是否存在频繁的垃圾回收

#### 5.任务管理器监控内存变化
- 任务管理器中各项数据中 内存指DOM元素所占据的内存 JavaScript内存中实时指的是当前活动对象所占据内存
- 主要关注的是javascript中实时内存的变化
- 主要作用：判断内存有无问题

#### 6.Timeline记录内存
- 通过对performance工具中内存随着时间线的延长而变化走向的分析
- 可以定位到具体某个时间节点中内存变化情况，并查看页面变化情况

#### 7.是否存在频繁的垃圾回收
###### 原因：
- GC工作时应用程序是停止的
- 频繁且过长的GC会造成应用假死
- 用户使用中感知到应用卡顿

###### 方法：
- Timeline中存在内存频繁的上升与下降
- 任务管理器中数据频繁的增大减小

## 五.代码优化实例

#### 1.如何精准测试JavaScript性能
- 本质：采集大量样本进行统计、分析
- 工具：基于Benchmark.js的https://jsperf.com/

###### Jsperf使用步骤：
1. 使用GitHub·账号登录
2. 填写个人信息
3. 填写详细的测试用例信息（title slug）,方便别人使用
4. 填写准备代码（DOM操作时使用）
5. 填写必要的setup与teardown代码
6. 填写测试代码片段

#### 2.慎用全局变量
###### 原因
- 变量定义在全剧执行上下文 局部变量往上查找时会消耗时间
- 全局变量一直存储于全局上下文执行栈 占据内存 直至程序退出
- 局部变量出现同名变量 会污染或遮蔽全局变量

#### 3.通過原型对象添加附加方法
这样做创建对象实例的效率更高

#### 4.避免通过对象的方法访问得到对象的属性

#### 5.for循环优化：
主动获取数组长度 避免在循环时每次去获取
```
const arr = [];
arr[10000] = 2232323;

for (let i = arr.length -1;i;i--) {
  console.log(arr[i]);
}

```

#### 6.文檔碎片优化节点添加
通过document.createDocumentFragment添加元素，可以提高性能

#### 7.克隆优化节点操作
通过克隆节点并进行添加的方式比直接创建并添加的方式性能更好
```
// 技术点：
dom.cloneNode(false1);

```

#### 7.直接量替换new Object
```
const arr1 = [1 ,3, 5]; // 更优

const arr2 = new Array(3);
arr2[0] = 1;
arr2[1] = 3;
arr2[2] = 5;

```